<!DOCTYPE html>
<html lang="en">
  <head>
    <title>Kinetik</title>
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.7/jquery.min.js"></script>
    <script src="/public/js/main.js"></script>
    <link rel="stylesheet" href="/public/css/main.css" type="text/css" media="all">
    <script type="text/javascript">
      var _gaq = _gaq || [];
      _gaq.push(['_setAccount', 'UA-28369129-2']);
      _gaq.push(['_trackPageview']);
      (function() {
        var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
        ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
        var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
      })();
    </script>
  </head>
  <body>
    <div class="wrapper">
      <header>
        <h1><a href="#top" class="scroll">Kinetik</a></h1>
        <div class="tagline"><p>A storage-agnostic, tag centric&lt;br /&gt;job queue for distributed applications.</p>
</div><a href="https://github.com/qualiancy/kinetik" class="fork">
          <h2>View the Project on GitHub</h2>
          <div class="project">qualiancy/kinetik</div></a>
        <nav>
          <div id="introduction" class="head"> <a href="#header-introduction" class="scroll">Introduction</a></div>
          <div id="guide" class="head"><a href="#header-guide" class="scroll">Quick Start Guide</a></div>
          <div id="install" class="section guide"><a href="#guide-install" class="scroll">Installation</a></div>
          <div id="storage" class="section guide"><a href="#guide-storage" class="scroll">Choosing a Storage Engine</a></div>
          <div id="tasks" class="section guide"><a href="#guide-tasks" class="scroll">Defining Tasks</a></div>
          <div id="processor" class="section guide"><a href="#guide-processor" class="scroll">Starting the Processor</a></div>
          <div id="jobs" class="section guide"><a href="#guide-jobs" class="scroll">Adding Jobs</a></div>
          <div id="queue_api" class="head"><a href="#header-queue_api" class="scroll">Queue API</a></div>
          <div id="tags" class="section queue_api"><a href="#queue_api-tags" class="scroll">tags</a></div>
          <div id="configure" class="section queue_api"><a href="#queue_api-configure" class="scroll">configure</a></div>
          <div id="use" class="section queue_api"><a href="#queue_api-use" class="scroll">use</a></div>
          <div id="define" class="section queue_api"><a href="#queue_api-define" class="scroll">define</a></div>
          <div id="create" class="section queue_api"><a href="#queue_api-create" class="scroll">create</a></div>
          <div id="process" class="section queue_api"><a href="#queue_api-process" class="scroll">process</a></div>
          <div id="fetch" class="section queue_api"><a href="#queue_api-fetch" class="scroll">fetch</a></div>
          <div id="cancel" class="section queue_api"><a href="#queue_api-cancel" class="scroll">cancel</a></div>
          <div id="clean" class="section queue_api"><a href="#queue_api-clean" class="scroll">clean</a></div>
          <div id="task_api" class="head"><a href="#header-task_api" class="scroll">Task API</a></div>
          <div id="tag" class="section task_api"><a href="#task_api-tag" class="scroll">tag</a></div>
          <div id="desc" class="section task_api"><a href="#task_api-desc" class="scroll">desc</a></div>
          <div id="timeout" class="section task_api"><a href="#task_api-timeout" class="scroll">timeout</a></div>
          <div id="action" class="section task_api"><a href="#task_api-action" class="scroll">action</a></div>
          <div id="retry" class="section task_api"><a href="#task_api-retry" class="scroll">retry</a></div>
          <div id="middleware" class="head"><a href="#header-middleware" class="scroll">Middleware</a></div>
          <div id="environment" class="section middleware"><a href="#middleware-environment" class="scroll">Environment</a></div>
          <div id="cli" class="section middleware"><a href="#middleware-cli" class="scroll">CLI</a></div>
          <div id="resources" class="head"><a href="#header-resources" class="scroll">Resources</a></div>
        </nav>
      </header>
      <section id="content">
        <div id="header-introduction" class="segment">
          <div class="para"><a href="#header-introduction">&para;</a></div>
          <div class="description"><h4>Features</h4>
<ul>
<li>storage-agnostic, thanks to <a href="https://github.com/qualiancy/seed">seed</a></li>
<li>distribute workers across processes and servers</li>
<li>tag and priority based processing</li>
<li>middleware capable</li>
<li>cli management suite</li>
<li>job delays</li>
<li>per-job logging</li>
<li>chainable api</li>
</ul>
<h4>Philosophy</h4>
<p>Simple tasks such as sending transactional emails and mobile notifications should be handled as
quickly as possible. Other tasks such as database analytics, adaptive re-keys, and media encoding
should occur when their are dedicated resources available. Kinetik&#39;s goal is to provide the 
framework necissary to handle both ends of the spectrum with simplicity and agility so your 
app can keep moving.

</p>
<h4>What is Seed?</h4>
<p>Seed is a suite of components (Graph, Model, Schema, Hash) that provide a common API 
for working with JSON-style documents, regardless of the storage engine. By using Seed, 
a Kinetik queue can be stored using any of Seed&#39;s storage adapters. 

</p>
<p><a href="http://github.com/qualiancy/seed">Visit the Seed project page</a> to learn more, and see alternative storage solutions.
Seed API documentation is in the works, so hold steady.

</p>
<p>Kinetik currently supports <a href="https://github.com/qualiancy/seed-redis">Redis</a> or 
<a href="https://github.com/qualiancy/seed-mongodb">MongoDB</a>. Stay tuned for developments 
regarding Riak and CouchDB. Need something else? The Seed Storage API will make it easy to 
integrate with your storage engine of choice.
</p>
</div>
        </div>
        <div id="header-guide" class="segment">
          <div class="para"><a href="#header-guide">&para;</a></div>
          <div class="description"><h2>Quick Start Guide</h2>
</div>
        </div>
        <div id="guide-install" class="segment">
          <div class="para"><a href="#guide-install">&para;</a></div>
          <div class="description"><h3>Installation</h3>
<p><code>kinetik</code> package is available for node through <a href="http://npmjs.org">npm</a>.

</p>
<pre><code class="lang-bash">npm install kinetik</code></pre>
</div>
        </div>
        <div id="guide-storage" class="segment">
          <div class="para"><a href="#guide-storage">&para;</a></div>
          <div class="description"><h3>Choosing a Storage Engine</h3>
<p>The first step to using Kinetik is creating a new queue using one of Seed&#39;s storage engines.
In this example we will use Redis with a default configuration.

</p>
<pre><code class="lang-javascript"><span class="keyword">var</span> kinetik = require(<span class="string">'kinetik'</span>)
  , RedisStore = require(<span class="string">'seed-redis'</span>)
  , queue = kinetik(<span class="keyword">new</span> RedisStore());</code></pre>
<p>You can use any of Seed&#39;s available storage adapters. See that adapater&#39;s documentation 
for relevant configuration options. Using a store is optional. If one is not provided, 
Kinetik will default to using an in memory store.

</p>
</div>
        </div>
        <div id="guide-tasks" class="segment">
          <div class="para"><a href="#guide-tasks">&para;</a></div>
          <div class="description"><h3>Defining Tasks</h3>
<p>In Kinetik, a task is a definition on how to process a given job. A job is a specific unit 
of work, and will encapsulate all of the data passed to it.

</p>
<p>Here we are going to define our first task, <code>send email</code>.

</p>
<pre><code class="lang-javascript">queue
  .define(<span class="string">'send email'</span>)
  .tag(<span class="string">'notifications'</span>)
  .action(<span class="function"><span class="keyword">function</span> <span class="params">(job, done)</span> {</span>
    <span class="keyword">var</span> email = job.data.email
      , subject = job.data.subject;

    myAsyncMailer(email, subject, body, <span class="function"><span class="keyword">function</span> <span class="params">(err)</span> {</span>
      <span class="keyword">if</span> (err) <span class="keyword">return</span> done(err);
      <span class="comment">// do more things if needed.</span>
      done();
    });
  });</code></pre>
<p>All task definition require a <code>tag</code> defined. A tag is an arbitrary string that allows 
us to group common types of jobs together for completion by a single worker process.

</p>
<p>The action is the function that will be used invoked to complete each job, it recieves
two arguments.

</p>
<ul>
<li>The <code>job</code> argument for the action will be comprised of all relevant data needed to
complete the task.</li>
<li>The <code>done</code> argument for the action accepts an error object as parameter. If an error 
is sent, it will  flag job as <code>failed</code>, otherwise will flag as <code>complete</code>.</li>
</ul>
</div>
        </div>
        <div id="guide-processor" class="segment">
          <div class="para"><a href="#guide-processor">&para;</a></div>
          <div class="description"><h3>Starting the Processor</h3>
<p>In the same node process that has the tasks defined, you will need to start processing. 
Processing is done per tag or group of tags.

</p>
<pre><code class="lang-javascript">queue.process(<span class="string">'notifications'</span>);</code></pre>
<p>This will begin processing the <code>notifications</code> tag. It will serially process all queued
jobs for that tag and then pause, then wait 10 seconds (see API to change), then query
for more to process. Multiple calls to <code>process</code> will create multiple &quot;threads&quot; of processing.
Avoid including the same tag in more than one processing call.

</p>
<p>You can also prioritize multiple tags for processing.

</p>
<pre><code class="lang-javascript">queue.process([ <span class="string">'notifications'</span>, <span class="string">'db aggregation'</span> ]);</code></pre>
<p>In this scenario, the queue will process all of the notifications, then move on to db
aggregation. If a notification is added to the queue while running a db aggregation
task, it will return to processing notifications at the completion of the current db
task. This behavior will occur even if their are more db tasks to accomplish. In that 
case, there will be no pause. The pause will only happen after all tags assigned for 
processing have been emptied.
</p>
</div>
        </div>
        <div id="guide-jobs" class="segment">
          <div class="para"><a href="#guide-jobs">&para;</a></div>
          <div class="description"><h3>Adding Jobs</h3>
<p>Finally, you will need to create jobs. 

</p>
<pre><code class="lang-javascript">queue.create(<span class="string">'send email'</span>, {
    email: <span class="string">'ford@hitchhikersguide.com'</span>
  , name: <span class="string">'Ford Prefect'</span>
  , subject: <span class="string">'Hello Universe'</span>
});</code></pre>
<p>One noteworthy feature of Kinetik is that jobs do
not have to be created with knowledge of the task that will process them. This means
that your task processing codebase does not need to be shared with the part of your 
application that will be creating jobs. As long as jobs are created using the the same
storage specifications as your processing queue, Kinetik will work as expected.

</p>
</div>
        </div>
        <div id="header-queue_api" class="segment">
          <div class="para"><a href="#header-queue_api">&para;</a></div>
          <div class="summary"><h2>Queue API</h2>
</div>
          <ul class="tags">
          </ul>
          <div class="description"><p>Queue constructor is the main interaction point for the
kinetik module. It should be constructed using a Seed
storage engines, and any of the below options.

</p>
<pre><code><span class="keyword">var</span> kinetik = require(<span class="string">'kinetik'</span>)
  , RedisStore = require(<span class="string">'seed-redis'</span>)
  , queue = kinetik(<span class="keyword">new</span> RedisStore(), { interval: <span class="string">'1m'</span> });

</code></pre>
<h5>Options</h5>
<ul>
<li><code>interval</code> [10s]: wait time after at tag or group of tags has been emptied</li>
</ul>
<h5>Events</h5>
<p>A queue is also an event emitter, which will relay
information about task status and the state of the jobs
being added to the queue. The following events can be
listened for:

</p>
<ul>
<li><code>error</code> - (err) - on any database related errors</li>
<li><code>drain</code> - () - when a stack of jobs have been saved to the db</li>
<li><code>empty</code> - (tags) - after processing a set of tags, prior to
pausing for interval duration</li>
<li><code>job:define</code> - (job) - when a job has been created and successfully
saved. In this case, job is a constructed Seed model.</li>
<li><code>task:define</code> - (task) - when a task has been defined</li>
</ul>
</div>
        </div>
        <div id="queue_api-tags" class="segment">
          <div class="para"><a href="#queue_api-tags">&para;</a></div>
          <div class="summary"><h3>.tags</h3>
</div>
          <ul class="tags">
          </ul>
          <div class="description"><p>A property that can be used to get a list
of all of the tags for tasks  attached to the
current queue instance. Cannot be set.

</p>
<pre><code>console.log(queue.tags); <span class="comment">// [ 'messaging' ]</span>
</code></pre>
</div>
        </div>
        <div id="queue_api-configure" class="segment">
          <div class="para"><a href="#queue_api-configure">&para;</a></div>
          <div class="summary"><h3>.configure ([env,] fn)</h3>
</div>
          <ul class="tags">
            <li class="tag"><span class="type">&#64;param</span><span class="types">&#123; String &#125;</span><span class="name">environment</span><span class="desc">to check (optional)</span></li>
            <li class="tag"><span class="type">&#64;param</span><span class="types">&#123; Function &#125;</span><span class="name">function</span><span class="desc">execute if match</span></li>
          </ul>
          <div class="description"><p>Run certain function only if NODE_ENV process
environment variable matches defined <code>env</code>.

</p>
<pre><code>queue.configure(<span class="string">'development'</span>, <span class="function"><span class="keyword">function</span> <span class="params">()</span> {</span>
  queue.use(kinetik.cli());
});
</code></pre>
</div>
        </div>
        <div id="queue_api-use" class="segment">
          <div class="para"><a href="#queue_api-use">&para;</a></div>
          <div class="summary"><h3>.use (fn)</h3>
</div>
          <ul class="tags">
            <li class="tag"><span class="type">&#64;param</span><span class="types">&#123; Function &#125;</span><span class="name">plugin</span><span class="desc">handle</span></li>
          </ul>
          <div class="description"><p>Load a specific plugin and attach it this queue
instance. Argument can either be a function or an
object with a method called <code>handle</code>. The parameter
passed to the function will be the current queue.
Useful for code re-use.

</p>
<pre><code>queue.use(<span class="function"><span class="keyword">function</span> <span class="params">(q)</span> {</span>
  q.on(<span class="string">'error'</span>, <span class="function"><span class="keyword">function</span> <span class="params">(err)</span> {</span>
    console.log(err.message);
  });
});
</code></pre>
</div>
        </div>
        <div id="queue_api-define" class="segment">
          <div class="para"><a href="#queue_api-define">&para;</a></div>
          <div class="summary"><h3>.define (name)</h3>
</div>
          <ul class="tags">
            <li class="tag"><span class="type">&#64;param</span><span class="types">&#123; String &#125;</span><span class="name">name</span><span class="desc"></span></li>
          </ul>
          <div class="description"><p>Creates a new task definition for this queue.
See the Task API for how to further configure a
task. Do not use the character <code>:</code> in your task
names as they are reserved for internal event
namespacing.

</p>
<pre><code><span class="keyword">var</span> sendEmail = queue.define(<span class="string">'send email'</span>);
</code></pre>
</div>
        </div>
        <div id="queue_api-create" class="segment">
          <div class="para"><a href="#queue_api-create">&para;</a></div>
          <div class="summary"><h3>.create (task, data[, delay])</h3>
</div>
          <ul class="tags">
            <li class="tag"><span class="type">&#64;param</span><span class="types">&#123; String &#125;</span><span class="name">task</span><span class="desc"></span></li>
            <li class="tag"><span class="type">&#64;param</span><span class="types">&#123; Object &#125;</span><span class="name">data</span><span class="desc">to pass to runner</span></li>
            <li class="tag"><span class="type">&#64;param</span><span class="types">&#123; Number | String &#125;</span><span class="name">delay</span><span class="desc">time specification</span></li>
          </ul>
          <div class="description"><p>Queue up a job with the given data attributes for
a given task. A <code>delay</code> can also be provided to prevent
a job from being processes until after a given timeframe.
Delay can either be in milliseconds, or a string in the
appropriate format.

</p>
<pre><code>queue.create(<span class="string">'send email'</span>, {
    email: <span class="string">'ford@hitchhikersguide.com'</span>
  , name: <span class="string">'Ford Prefect'</span>
  , subject: <span class="string">'Welcome to the Guide'</span>
}, <span class="string">'1d'</span>);

</code></pre>
<p>Stringed timestamps can be in any of the following
formats: <code>10ms</code>, <code>30s</code>, <code>45m</code>, <code>2h</code>, <code>6d</code>.

</p>
<p>The job that is created will be saved asyncronously. If
you wish to know when all created jobs in the current
scope have been saved, you can listen for the queue
<code>drain</code> event.
</p>
</div>
        </div>
        <div id="queue_api-process" class="segment">
          <div class="para"><a href="#queue_api-process">&para;</a></div>
          <div class="summary"><h3>.process (tags, [interval])</h3>
</div>
          <ul class="tags">
            <li class="tag"><span class="type">&#64;param</span><span class="types">&#123; Array &#125;</span><span class="name">tags</span><span class="desc">in order of priority</span></li>
            <li class="tag"><span class="type">&#64;param</span><span class="types">&#123; String | Number &#125;</span><span class="name">time</span><span class="desc">to wait between checks</span></li>
          </ul>
          <div class="description"><p>Start a process loop for a given set of tags.
An interval can also be provided to override the
queue interval as the delay between checking for
more jobs on the event of all tags being empty.

</p>
<pre><code><span class="comment">// use default interval (10s)</span>
queue.process(<span class="string">'urgent'</span>);

<span class="comment">// check every second</span>
queue.process(<span class="string">'long'</span>, <span class="number">1000</span>);

<span class="comment">// check every 10 minutes</span>
queue.process([ <span class="string">'messaging'</span>, <span class="string">'dbaggr'</span> ], <span class="string">'10m'</span>);

</code></pre>
<p>For more information on the behavior of
<code>queue.process</code>, see the Quick Start guide on
&quot;Starting the Processor&quot;.
</p>
</div>
        </div>
        <div id="queue_api-fetch" class="segment">
          <div class="para"><a href="#queue_api-fetch">&para;</a></div>
          <div class="summary"><h3>.fetch (query, callback)</h3>
</div>
          <ul class="tags">
            <li class="tag"><span class="type">&#64;param</span><span class="types">&#123; Object &#125;</span><span class="name">query</span><span class="desc"></span></li>
            <li class="tag"><span class="type">&#64;param</span><span class="types">&#123; Function &#125;</span><span class="name">callback</span><span class="desc">will return params err||null, graph.</span></li>
          </ul>
          <div class="description"><p>Allows for direct access to Seed Graph of of jobs for
data manipulation. Useful if you want to retrieve jobs
that were previously scheduled or completed. Also, used
internally for various tasks, such as cleaning or stats.

</p>
<p>No matter which store you are using, the query should
be formatted according to Seed&#39;s query language, which is
a MongoDB compatible, object based query language.

</p>
<p>The returned <code>jobs</code> parameter in the callback is a Seed.Hash
instance. Here is a sample map/reduce pattern that will get
the count of queued jobs by task:

</p>
<pre><code>queue.fetch({ status: <span class="string">'queued'</span> }, <span class="function"><span class="keyword">function</span> <span class="params">(err, jobs)</span> {</span>
  <span class="keyword">if</span> (err) <span class="keyword">throw</span> err;

  <span class="comment">// aggregate by task name</span>
  <span class="function"><span class="keyword">function</span> <span class="title">map</span> <span class="params">(key, value, emit)</span> {</span>
    <span class="keyword">var</span> task = value.get(<span class="string">'task'</span>);
    emit(task, <span class="number">1</span>);
  }

  <span class="comment">// reduce by count of emit's per task</span>
  <span class="function"><span class="keyword">function</span> <span class="title">reduce</span> <span class="params">(key, value)</span> {</span>
    <span class="keyword">return</span> value.length;
  }

  <span class="comment">// task welcome email has [42] queued jobs</span>
  <span class="function"><span class="keyword">function</span> <span class="title">display</span> <span class="params">(value, key)</span> {</span>
    console.log(<span class="string">'task %s has [%d] queued jobs'</span>, key, value);
  }

  <span class="comment">// run it</span>
  jobs
    .mapReduce(map, reduce)
    .each(display);
});
</code></pre>
</div>
        </div>
        <div id="queue_api-cancel" class="segment">
          <div class="para"><a href="#queue_api-cancel">&para;</a></div>
          <div class="summary"><h3>.cancel (job, callback)</h3>
</div>
          <ul class="tags">
            <li class="tag"><span class="type">&#64;param</span><span class="types">&#123; Job | ObjectId &#125;</span><span class="name">job</span><span class="desc">instance or id</span></li>
            <li class="tag"><span class="type">&#64;param</span><span class="types">&#123; Function &#125;</span><span class="name">callback</span><span class="desc">upon completion (optional)</span></li>
          </ul>
          <div class="description"><p>Cancel a specific job. Accepts either job
instance of Seed.Model or id of job. If you
cancel jobs using the method on the same constructed
queue in which the job&#39;s task is defined, a
<code>cancelled</code> event will be emitted to that task.

</p>
<pre><code><span class="keyword">var</span> id = job.id;
queue.cancel(job, <span class="function"><span class="keyword">function</span> <span class="params">(err)</span> {</span>
  <span class="keyword">if</span> (err) <span class="keyword">throw</span> err;
  console.log(<span class="string">'job %j has been cancelled'</span>, id);
});
</code></pre>
</div>
        </div>
        <div id="queue_api-clean" class="segment">
          <div class="para"><a href="#queue_api-clean">&para;</a></div>
          <div class="summary"><h3>.clean (tags, callback)</h3>
</div>
          <ul class="tags">
            <li class="tag"><span class="type">&#64;param</span><span class="types">&#123; String | Array &#125;</span><span class="name">tags</span><span class="desc">(optional)</span></li>
            <li class="tag"><span class="type">&#64;param</span><span class="types">&#123; Function &#125;</span><span class="name">callback</span><span class="desc"></span></li>
          </ul>
          <div class="description"><p>Remove all complete tasks for given (optional)
tags. Will call callback upon completion. If no
tags are specified, all tags will be cleaned.
Only removes jobs which have a <code>completed</code> status;
jobs which have timed out or failed will still remain.

</p>
<pre><code>queue.clean(<span class="string">'messaging'</span>, <span class="function"><span class="keyword">function</span> <span class="params">(err)</span> {</span>
  <span class="keyword">if</span> (err) <span class="keyword">throw</span> err;
  console.log(<span class="string">'all completed messaging jobs have been removed'</span>);
});
</code></pre>
</div>
        </div>
        <div id="header-task_api" class="segment">
          <div class="para"><a href="#header-task_api">&para;</a></div>
          <div class="summary"><h2>Task API</h2>
</div>
          <ul class="tags">
          </ul>
          <div class="description"><p>When using the <code>define</code> method from your Queue, you will
be returned a new instance of a <code>Task</code>. In Kinetik, the purpose
of a task is to define how to process a given job.

</p>
<pre><code><span class="keyword">var</span> task = queue.define(<span class="string">'email.welcome'</span>)
  .tag(<span class="string">'messaging'</span>)
  .action(<span class="function"><span class="keyword">function</span> <span class="params">(job, done)</span> {</span>
    <span class="keyword">var</span> locals = { name: job.data.name };
    render(<span class="string">'./emails/welcome.jade'</span>, locals, <span class="function"><span class="keyword">function</span> <span class="params">(err, html)</span> {</span>
      <span class="keyword">if</span> (err) <span class="keyword">return</span> done(err);
      asyncMailer(email, html, <span class="function"><span class="keyword">function</span> <span class="params">(err, transId)</span> {</span>
        <span class="keyword">if</span> (err) <span class="keyword">return</span> done(err);
        job.log(<span class="string">'Email sent'</span>, { receipt: transId });
        done();
      });
    });
  });

</code></pre>
<h5>Necessities</h5>
<p>Each task is created with a unique <code>name</code> that will be referenced
when you create jobs. This is completely arbitrary, but avoid using
<code>:</code> as a namespace delimeter, as Kinetik uses that internally.

</p>
<p>The <code>tag</code> is used to group the jobs for the queue processor. These
are arbitrary keywords and can be as simple as priorities, such as
<code>normal</code> and <code>important</code> OR task groupings such as <code>messaging</code> and
<code>db aggregation</code>.

</p>
<p>The <code>action</code> is the function that is to be executed to process the job.
Actions are asyncronous by nature and are provide a number of helper
methods from Kinetik (more later).

</p>
<h5>Events</h5>
<p>A task is also an event-emitter which will emit the following events
for each job that is processed through a task.

</p>
<ul>
<li><code>complete</code> - (job) - when a job has completed</li>
<li><code>fail</code> - (err, job) - when a job has failed errored</li>
<li><code>timeout</code> - (job) - when a job has timed out</li>
<li><code>log</code> - (job, line) - when a job has logged a line of data</li>
<li><code>progress</code> - (job, current, total) - when the progress helper is emitted</li>
</ul>
<p>In all of the events, the <code>job</code> parameter provided is a job
model that can be updated and saved to your data store. This
allows you the flexibility to:

</p>
<ul>
<li>Provide your own re-queue methodology.</li>
<li>Delete jobs that have been completed.</li>
</ul>
<p>You should, however, avoid updating the log model during a <code>log</code> or
<code>progress</code> event as the action is still being processed. The status
events occur after the results of the job have been committed to the
database.
</p>
</div>
        </div>
        <div id="task_api-tag" class="segment">
          <div class="para"><a href="#task_api-tag">&para;</a></div>
          <div class="summary"><h3>.tag (tag)</h3>
</div>
          <ul class="tags">
            <li class="tag"><span class="type">&#64;param</span><span class="types">&#123; String &#125;</span><span class="name">tag</span><span class="desc"></span></li>
          </ul>
          <div class="description"><p>Tag a task as belonging to a given tag. All tasks
require a tag to be found by the queue processor, but
tasks will use <code>default</code> until this is defined.

</p>
<pre><code>task.tag(<span class="string">'urguent'</span>)
</code></pre>
</div>
        </div>
        <div id="task_api-desc" class="segment">
          <div class="para"><a href="#task_api-desc">&para;</a></div>
          <div class="summary"><h3>.desc (description)</h3>
</div>
          <ul class="tags">
            <li class="tag"><span class="type">&#64;param</span><span class="types">&#123; String &#125;</span><span class="name">description</span><span class="desc"></span></li>
          </ul>
          <div class="description"><p>Provide a short description about the task being
defined. This can be used by middleware.
</p>
</div>
        </div>
        <div id="task_api-timeout" class="segment">
          <div class="para"><a href="#task_api-timeout">&para;</a></div>
          <div class="summary"><h3>.timeout (duration)</h3>
</div>
          <ul class="tags">
            <li class="tag"><span class="type">&#64;param</span><span class="types">&#123; Number | String &#125;</span><span class="name">duration</span><span class="desc"></span></li>
          </ul>
          <div class="description"><p>Provides a timeout duration for the action. If this
time length has been reached an action will be marked
as <code>timeout</code>. If no timeout value is defined, an action
can run indefinately. Even though the <code>action</code> function
is still running in limbo, Kinetik will have moved on
and any attempts to change the status of the job or
emit log and progress will be ignored.

</p>
<pre><code>task.timeout(<span class="number">10000</span>); <span class="comment">// 10 seconds</span>
task.timeout(<span class="string">'1m'</span>); <span class="comment">// 1 minute</span>
</code></pre>
</div>
        </div>
        <div id="task_api-action" class="segment">
          <div class="para"><a href="#task_api-action">&para;</a></div>
          <div class="summary"><h3>.action (fn)</h3>
</div>
          <ul class="tags">
            <li class="tag"><span class="type">&#64;param</span><span class="types">&#123; Function &#125;</span><span class="name">action</span><span class="desc">function</span></li>
          </ul>
          <div class="description"><p>Provides an action for a given task. When executed,
the action will receive two arguments:

</p>
<ul>
<li><code>job</code> - <em>{Object}</em> - encapsulats everything about a job</li>
<li><code>done</code> - <em>{Function}</em> - indicates when the action has completed</li>
</ul>
<p>In the <code>job</code> object, the following properties are available.

</p>
<ul>
<li><code>id</code> - <em>{Number|String}</em> - the id of the job according to your database</li>
<li><code>data</code> - <em>{Object}</em> - data attributes passed on job creation</li>
<li><code>progress</code> - <em>{Function}</em> - indicate the progress of actions
with multiple steps.</li>
<li><code>log</code> - <em>{Function}</em> - method used to log a line item to the
database for that job.</li>
</ul>
<h5>Indicating Progress</h5>
<p>You can use the <code>progress</code> method to indicate the current position
if the task has multiple steps. This is not saved to the database, but
instead emitted as the <code>progress</code> event on onto the task.

</p>
<pre><code><span class="comment">// current, total</span>
job.progress(<span class="number">10</span>, <span class="number">100</span>);

</code></pre>
<h5>Logging</h5>
<p>Each task can have log items associated with them. Kinetik creates
a few of these on creation, completion, failure, and timeout. You
also have the ability to create these. Each one is timestamped and
can include a message and options JSON data to accompany the log item.

</p>
<pre><code><span class="comment">// message, data</span>
job.log(<span class="string">'Email send complete.'</span>, { receipt: transactionId });

</code></pre>
<p>During a job run these are emitted immediately as the <code>log</code> event
to the task. They are also stored in memory and pushed the the
database as a batch at the completion of action.

</p>
<h5>Indicating Completion</h5>
<p>If you want to mark the job as <code>errored</code> as opposed to
<code>completed</code>, you can send a parameter to the done function.

</p>
<pre><code>done(<span class="string">'This job completed with an error.'</span>);
done(<span class="keyword">new</span> Error(<span class="string">'This job completed with an error.'</span>);

</code></pre>
<p>If a string is provided it will be logged as the error message;
if an object (such as a constructed javascript  <code>Error</code>) is sent,
kinetik will attempt to read the the object&#39;s <code>message</code> property as
the failure reason, and also the error <code>code</code> property if there is
one.
</p>
</div>
        </div>
        <div id="task_api-retry" class="segment">
          <div class="para"><a href="#task_api-retry">&para;</a></div>
          <div class="summary"><h3>.retry</h3>
</div>
          <ul class="tags">
            <li class="tag"><span class="type">&#64;param</span><span class="types">&#123; Number | String &#125;</span><span class="name">duration</span><span class="desc">between two retries</span></li>
            <li class="tag"><span class="type">&#64;param</span><span class="types">&#123; String &#125;</span><span class="name">number</span><span class="desc">of retries, infinite if not set</span></li>
          </ul>
          <div class="description"><p>define if the task should be re-run when it fails
</p>
</div>
        </div>
        <div id="header-middleware" class="segment">
          <div class="para"><a href="#header-middleware">&para;</a></div>
          <div class="description"><h2>Middleware</h2>
<p>Middleware provides a way to hook into the events and methods of a queue. The API is in
its infancy, but expect great things in the near future.

</p>
<h5>Current Middleware</h5>
<ul>
<li><code>environment</code> - start multiple queue runners based on environment variables</li>
<li><code>cli</code> - perform maintaince on your queue/jobs using a cli</li>
</ul>
<h5>Roadmap</h5>
<p>This are the middleware &quot;apps&quot; that Kinetik currently has planned. If you are interested in
contributing, please contact <a href="http://twitter.com/jakeluer">@jakeluer</a> on Twitter.

</p>
<ul>
<li>HTTP API for job management</li>
<li>Network capable event bus</li>
<li>Web App UI</li>
</ul>
</div>
        </div>
        <div id="middleware-environment" class="segment">
          <div class="para"><a href="#middleware-environment">&para;</a></div>
          <div class="description"><h3>Environment</h3>
<p>The environment middleware allows you to easily start multiple job processing node processes
based on a set of tags. This allows you to fully utilize the resources of the server or 
servers that Kinetik is running on. Make sure that you are using one of Seed&#39;s database
storage engines.

</p>
<p>To use the <code>environment</code> middleware, start of creating a queue and defining tasks as normal, but
avoid calling <code>queue.process</code> directly. Instead, end your program with the following <code>use</code>
mechanism:

</p>
<pre><code class="lang-js"><span class="keyword">var</span> kinetik = require(<span class="string">'kinetik'</span>)
  , RedisStore = require(<span class="string">'seed-redis'</span>)
  , queue = kinetik(<span class="keyword">new</span> RedisStore());

<span class="comment">// define all your tasks</span>

queue.use(kinetik.environment());</code></pre>
<p>This tells the queue to look for the <code>QUEUE</code> environment variable and being processing only if 
a list of tags are passed to it. If no <code>QUEUE</code> variable is found, the queue will not begin processing.

</p>
<p>To start the queue, you then invoke your queue from the command line.

</p>
<pre><code class="lang-bash">QUEUE=messaging node queue.js</code></pre>
<p>This will start the queue processing the <code>messaging</code> tag. You can also spin up multiple processes
including multiple tags.

</p>
<pre><code class="lang-bash">QUEUE=messaging node queue.js
QUEUE=db.aggregation,log.rotate node queue.js</code></pre>
<p>You now have two node processes working on your queue. 
</p>
</div>
        </div>
        <div id="middleware-cli" class="segment">
          <div class="para"><a href="#middleware-cli">&para;</a></div>
          <div class="description"><h3>Command-line Interface</h3>
<p>The command-line interface works best when paired with the <code>environment</code> middleware.
Since <code>node queue.js</code> won&#39;t do anything without the <code>QUEUE</code> environment variable, you
are free to use those calls for other things, such as performing maintainance and getting
statistics.

</p>
<h5>Setup</h5>
<p>Rather simple, really:

</p>
<pre><code class="lang-js">queue.use(kinetik.environment());
queue.use(kinetik.cli());</code></pre>
<p>Now you are free to use that file as your CLI. Assuming <code>queue.js</code> was your file:

</p>
<pre><code class="lang-bash">node queue.js --help</code></pre>
<p><img src="/public/img/kinetik.help.png" alt="Kinetik --help">

</p>
<h4>Commands</h4>
<h5>tasks</h5>
<p>Get a list of all of the tasks for this queue:

</p>
<p><img src="/public/img/kinetik.tasks.png" alt="Kinetik tasks">

</p>
<h5>jobs</h5>
<p>Get a list of all of the jobs in this queue. Also shows a breakdown of the current status
of each job by task.

</p>
<p><img src="/public/img/kinetik.jobs.png" alt="Kinetik jobs">

</p>
<h5>clean</h5>
<p>Clean jobs of a given status, optionally by tag. Will default to <code>completed</code> if no
status option is provided. Furthermore, all logs associated with the jobs removed will
also be removed.

</p>
<p><img src="/public/img/kinetik.clean.png" alt="Kinetik clean">
</p>
</div>
        </div>
        <div id="header-resources" class="segment">
          <div class="para"><a href="#header-resources">&para;</a></div>
          <div class="description"><h2>Resources</h2>
<h4>Tests</h4>
<p>Tests are writting in <a href="http://github.com/visionmedia/mocha">Mocha</a> using 
the <a href="http://chaijs.com">Chai</a> <code>should</code> BDD assertion library. To make sure you 
have that installed, clone this repo, install dependacies using <code>npm install</code>.

</p>
<pre><code class="lang-bash">make test</code></pre>
<p>By default, Kinetik will use a MemoryStore to task all of its functionality.
You can also test database integration with Redis and MongoDB. Make sure that you
have both installed locally and setup with default configs without authentication.

</p>
<pre><code class="lang-bash">make test-int</code></pre>
<p>The tests will aggressively clean up after themselves. Mongo will remove the collection 
that it created and Redis with flush the default database. You may alter this behavior 
by commenting out a few lines in <code>test/storage.js</code>.

</p>
<h4>Contributors</h4>
<p>Interested in contributing? Fork to get started. Contact <a href="http://github.com/logicalparadox">@logicalparadox</a> 
if you are interested in being regular contributor.

</p>
<ul>
<li>Jake Luer (<a href="http://github.com/logicalparadox">@logicalparadox</a>)</li>
</ul>
<h4>License</h4>
<p>(The MIT License)
</p>
</div>
        </div>
        <footer><a href="http://qualiancy.com" class="qual"><img src="http://qualiancy.com/img/qualiancy-logo.png" class="qlogo"></a></footer>
      </section>
    </div>
  </body>
</html>